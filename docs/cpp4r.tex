% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={C++ for Rustaceans},
  pdfauthor={Tianyi Shi},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{fontspec}
\usepackage[slantfont, boldfont]{xeCJK}

\setCJKmainfont{Source Han Serif}
\setCJKmonofont{Source Han Serif}
\setCJKsansfont{YouYuan}

\usepackage{lscape}
\usepackage{pdfpages}
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{C++ for Rustaceans}
\author{Tianyi Shi}
\date{2020-11-15}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{disclaimer}{%
\chapter*{Disclaimer}\label{disclaimer}}
\addcontentsline{toc}{chapter}{Disclaimer}

I am neither a pro in Rust nor in C++. It is possible that some of my conceptual understandings are wrong, and it is very likely that some examples, especially C++ ones, are not the best practice. I could only promise that all programs should compile and run without safety issues. If you spot anything that could be improved, please submit a PR!

\hypertarget{about-this-book}{%
\chapter*{About this Book}\label{about-this-book}}
\addcontentsline{toc}{chapter}{About this Book}

I'm a biochemistry student wishing to specialize in computational biology, and I need a fast (specifically, no-GC) language for implementing algorithms. Since the decision was made in April 2020, I naturally chose Rust. Soon I fell in love with it. Cargo, rustdoc, crates.io, clippy etc. just makes Rust so nice--even better than Python. However, I have to face the reality: the majority of bioinformatics algorithms to date are written in C or C++ (either as pure C or C++ libraries or as extensions to Python or R), and most labs are still developing on them. It turns out that some C and C++ literacy is necessary for me.

While there is a project called \href{https://github.com/nrc/r4cppp}{r4cppp} that introduces Rust to C++ programmers, I haven't found any cpp4r, so I started this one. I'm not an expert in Rust and C++ and I'm writing this book while learning them, so it'll be more like a personal notebook than a perfessional guide. I'll try to make it readable, though.

\hypertarget{prerequisites}{%
\chapter*{Prerequisites}\label{prerequisites}}
\addcontentsline{toc}{chapter}{Prerequisites}

I'm assuming you're an intermediate-level Rustacean. You should understand the majority of the concepts in \href{https://doc.rust-lang.org/book/}{The Book} and also the basics of raw pointers.

You'll need a C++ compiler. I recommend using \texttt{clang++} on Linux \& MacOS because it generally gives better error message than \texttt{g++}. On Windows you should use \texttt{msvc}.

\hypertarget{hello-c}{%
\chapter{Hello C++}\label{hello-c}}

In this chapter, we'll learn the very basics of C++.

\hypertarget{hello-world}{%
\section{Hello world}\label{hello-world}}

This is a hello world program in C++:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} }\StringTok{"Hello C++!"}\NormalTok{ \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Write the above code in \texttt{hello.cpp}, then you can compile it with
\texttt{g++\ hello.cpp\ -o\ hello} and run \texttt{./hello} (you can replace \texttt{g++} with \texttt{clang++}
or any other compiler).

A couple of things to note here:

Every C++ executable (as opposed to library) must have a \texttt{main()} function that
returns \texttt{int}. Returning \texttt{0} signifies that the program terminates without errors.
The final \texttt{return\ 0;} statement can be omitted in the \texttt{main()} function.

\texttt{\#include} is a preprocessor. We'll meet more preprocessors in the future, for now
just accept that they are ``naive macros'' that are ``expanded'' before the actual
compilation.
Here \texttt{\#include} copies the content of file called \texttt{iostream}, which has tens of
thousands lines, and pastes it here. Yes, it literally does so, and you can check
this by running \texttt{g++\ -E\ main.c}, which ``expands'' all preprocessor statements.

\texttt{iostream} contains definitions of functions and objects such as \texttt{std::cout} and
\texttt{std::endl}, which are used for IO manipulations. \texttt{cout} stands for ``character
output'', and \texttt{endl} stands for ``endline'' (it appends \texttt{\textbackslash{}n} and flushes the buffer).
\texttt{\textless{}\textless{}} is the bitwise left shift operator, and the designers of C++ decided that
overloading bitwise shift operators for \texttt{cout} and \texttt{cin} can make C++ look fancy
from the beginning. That's why we need to learn yet another special syntax.

\texttt{iostream} also introduces another function into scope, the C-compatible \texttt{printf} into scope,
which can also be used to print ``Hello world''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf(}\StringTok{"Hello from printf}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

Now you might begin to wonder, why isn't \texttt{std::cout} called \texttt{std::iostream::cout},
and why \texttt{printf} can be called without any prefix. This is because in C++ filenames
have no relationships to \texttt{namespace}s by default. \texttt{namespace} is similar to Rust's \texttt{mod},
but more flexible. In this case, the \texttt{iostream} file contains something conceptually like this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ printf(...);}

\KeywordTok{namespace}\NormalTok{ std \{}
    \KeywordTok{class}\NormalTok{ cout \{\}}
    \KeywordTok{class}\NormalTok{ endl \{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{printf} isn't placed inside \texttt{std} because it is a heritage from C. Many other C functions
are also available in C++, and they can be distinguished by the absence of the \texttt{std::} prefix.

\hypertarget{data-types}{%
\section{Data Types}\label{data-types}}

\hypertarget{integer-types}{%
\subsection{Integer Types}\label{integer-types}}

The following table summarises the relationship between Rust's and C++'s integer data types:

\begin{longtable}[]{@{}ccc@{}}
\toprule
Rust & C++ & C \& C++\tabularnewline
\midrule
\endhead
\texttt{i8} & \texttt{int8\_t} & \texttt{char}\tabularnewline
\texttt{i16} & \texttt{int16\_t} & \texttt{short}\tabularnewline
\texttt{i32} & \texttt{int32\_t} & \texttt{int}\tabularnewline
\texttt{i64} & \texttt{int64\_t} & \texttt{long}\tabularnewline
\texttt{i128} & &\tabularnewline
\texttt{u8} & \texttt{uint8\_t} & \texttt{unsigned\ char}\tabularnewline
\texttt{u16} & \texttt{uint16\_t} & \texttt{unsigned\ short}\tabularnewline
\texttt{u32} & \texttt{uint32\_t} & \texttt{unsigned\ int}\tabularnewline
\texttt{u64} & \texttt{uint64\_t} & \texttt{unsigned\ long}\tabularnewline
\texttt{u128} & &\tabularnewline
\texttt{isize} & &\tabularnewline
\texttt{usize} & \texttt{size\_t} &\tabularnewline
\bottomrule
\end{longtable}

While the equivalence between the first column and the second column always holds true,
the third column depends on the platform and here I'm assuming you're on a modern, 64-bit
system.

While the relationships described in the table are always true, C++'s integer types
are much more complex. The types above are fixed width integer types, and there are
additional integer types whose width is dependent on the implementation. These include
C-compatible ones (i.e.~\texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{long\ long}), and other C++
artifects such as \texttt{int\_fast16\_t} and \texttt{int\_least32\_t}. You can learn about them at
\href{https://en.cppreference.com/w/cpp/types/integer}{cppreference}.

\hypertarget{floating-point-numbers}{%
\subsection{Floating Point Numbers}\label{floating-point-numbers}}

For floating numbers, \texttt{f32} and \texttt{f64} correspond to \texttt{float} and \texttt{double}, respectively
(stand for single-precision and double-precision floating point numbers).

\hypertarget{variables}{%
\section{Variables}\label{variables}}

Like in Rust, creating a variable requires two steps, declaration and initialization.

The traditional syntax for declaration and initialization is \texttt{\textless{}type\textgreater{}\ \textless{}var\ name\textgreater{}\ =\ \textless{}value\textgreater{};},
and these two steps can be separated:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a = }\DecValTok{5}\NormalTok{;}
\DataTypeTok{char}\NormalTok{ b;}
\NormalTok{b = }\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

The above syntax is compatible with C, which has a problem: if you initialize an \texttt{int} with a float:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a = }\FloatTok{5.5}\NormalTok{;}
\OtherTok{assert}\NormalTok{(a == }\DecValTok{5}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

The value will be implicitly converted (recent compilers will give a warning when this happens; see Figure \ref{fig:equal}).
C++11 introduced the ``uniform initialization'' syntax, which forbids this implicit conversion. In its simplest form:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a\{}\DecValTok{5}\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{img/equal.png}
\caption{\label{fig:equal}When implicit conversion occurs, a decent modern C++ compiler will give a warning.}
\end{figure}

If you try \texttt{int\ a\{5.5\};} with this syntax, the compiler will give an error and abort (Figure \ref{fig:braces} ). In addition, you can't separate the two parts:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// not allowed}
\DataTypeTok{int}\NormalTok{ a;}
\NormalTok{a\{}\DecValTok{5}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{img/brace.png}
\caption{\label{fig:braces}The uniform initialization syntax.}
\end{figure}

Of course, the uniform initialization syntax isn't invented just to prevent implicit conversion. As you'll see later, it can become handy when initializing complicated, non-primitive data types.

\hypertarget{mutability}{%
\subsection{Mutability}\label{mutability}}

Variables are mutable by default. If you want to create an immutable variable, use the \texttt{const} keyword.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{let}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\KeywordTok{let} \KeywordTok{mut}\NormalTok{ b }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//C++}
\AttributeTok{const} \KeywordTok{auto}\NormalTok{ a = }\DecValTok{5}\NormalTok{;}
\KeywordTok{auto}\NormalTok{ b = }\DecValTok{10}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{const} is used to create an immutable variable, how to create a real ``constant'' that's evaluated at compile time? The answer is \texttt{consexpr}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{const}\NormalTok{ LIGHT\_SPEED}\OperatorTok{:} \DataTypeTok{f64} \OperatorTok{=} \DecValTok{2.99792458e8}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{constexpr} \DataTypeTok{double}\NormalTok{ LIGHT\_SPEED = }\FloatTok{2.99792458e8}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

What about constant strings? Well, like Rust, you can't use the dynamically allocated \texttt{std::string}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{const}\NormalTok{ NAME}\OperatorTok{:} \DataTypeTok{String} \OperatorTok{=} \StringTok{"Hideyo"}\OperatorTok{.}\NormalTok{to\_string()}\OperatorTok{;} \CommentTok{// not allowed!}
\KeywordTok{const}\NormalTok{ NAME}\OperatorTok{:} \OperatorTok{\&}\OtherTok{\textquotesingle{}static} \DataTypeTok{str} \OperatorTok{=} \StringTok{"Hideyo"}\OperatorTok{;}       \CommentTok{// good}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//C++}
\KeywordTok{constexpr} \BuiltInTok{std::}\NormalTok{string NAME = }\StringTok{"Hideyo"}\NormalTok{; }\CommentTok{// not allowed!}
\KeywordTok{constexpr} \DataTypeTok{char}\NormalTok{ NAME[] = }\StringTok{"Hideyo"}\NormalTok{;      }\CommentTok{// good}
\end{Highlighting}
\end{Shaded}

So you have to use an array of characters. Well, it's technically closer to \texttt{const\ NAME:\ \&{[}u8{]}\ =\ b"Hideyo";}. Then, if you need to use the \texttt{std::string}, you need explicit conversion:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\KeywordTok{constexpr} \DataTypeTok{char}\NormalTok{ NAME[] = }\StringTok{"Hideyo"}\NormalTok{;}
\KeywordTok{constexpr} \DataTypeTok{char}\NormalTok{ NAME\_UTF8[] = }\StringTok{"英世"}\NormalTok{;}

\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \AttributeTok{const} \BuiltInTok{std::}\NormalTok{string NAME\_STRING(NAME);}
    \AttributeTok{const} \BuiltInTok{std::}\NormalTok{string NAME\_UTF8\_STRING(NAME\_UTF8);}
    \CommentTok{// thank god UTF8 works! If you were in C you would have a hard time.}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} NAME\_UTF8\_STRING \textless{}\textless{} }\StringTok{" "}\NormalTok{ \textless{}\textless{} NAME\_STRING \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions}{%
\section{Functions}\label{functions}}

Functions are declared and defined in the following way:

\begin{verbatim}
<return_type> <function_name>(<params>) {
    // do something
    return something;
}
\end{verbatim}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{float}\NormalTok{ square(}\DataTypeTok{float}\NormalTok{ a)}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ a * a;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \DataTypeTok{float}\NormalTok{ x = }\FloatTok{2.5}\NormalTok{;}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} }\StringTok{"square of "}\NormalTok{ \textless{}\textless{} x \textless{}\textless{} }\StringTok{"is"}\NormalTok{ \textless{}\textless{} square(x) \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that a function must be \emph{declared} before it can be used. This means the following won't work:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\CommentTok{// float square(float);}

\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \DataTypeTok{float}\NormalTok{ x = }\FloatTok{2.5}\NormalTok{;}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} }\StringTok{"square of "}\NormalTok{ \textless{}\textless{} x \textless{}\textless{} }\StringTok{"is"}\NormalTok{ \textless{}\textless{} square(x) \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}


\DataTypeTok{float}\NormalTok{ square(}\DataTypeTok{float}\NormalTok{ a)}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ a * a;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

However, by uncommenting the third line, it works. When you use a function, the compiler must know the signature, but not necessarily the \emph{definition} of the function. This is why in C++ (and in C) people split their funtions into signatures which go into header files, and definitions which go into \texttt{.cpp} files. I'll get back to header files later. For now we'll be working with single-file programs without splitting declaration and definitions.

\hypertarget{pointers-and-references}{%
\section{Pointers and References}\label{pointers-and-references}}

Let's revisit how we make references and pointers in Rust:

In Rust, when you take a reference to a type \texttt{T}, the type of the reference is \texttt{\&T}. Basically, you add \texttt{\&} to both LHS and RHS:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// type annotations are not required; this is just for demonstration}
\KeywordTok{let}\NormalTok{   a}\OperatorTok{:}  \DataTypeTok{i32} \OperatorTok{=}  \DecValTok{5}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ r\_a}\OperatorTok{:} \OperatorTok{\&}\DataTypeTok{i32} \OperatorTok{=} \OperatorTok{\&}\NormalTok{a}\OperatorTok{;} \CommentTok{// r\_a == \&5}
\end{Highlighting}
\end{Shaded}

and when you deference, you use \texttt{*}. Just remember that \texttt{*} is the reverse of \texttt{\&}, and every \texttt{*} removes one \texttt{\&} from both LHS and RHS:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ r\_a}\OperatorTok{:} \OperatorTok{\&}\DataTypeTok{i32} \OperatorTok{=} \OperatorTok{\&}\DecValTok{5}\OperatorTok{;}
\KeywordTok{let}\NormalTok{   a}\OperatorTok{:}  \DataTypeTok{i32} \OperatorTok{=} \OperatorTok{*}\NormalTok{r\_a}\OperatorTok{;} \CommentTok{// a == 5}
\KeywordTok{let}\NormalTok{   a}\OperatorTok{:}  \DataTypeTok{i32} \OperatorTok{=} \OperatorTok{*\&*\&*\&}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

You can coerce a reference into a raw pointer, using either of the two syntaxes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ p\_a}\OperatorTok{:} \OperatorTok{*}\KeywordTok{const} \DataTypeTok{i32} \OperatorTok{=} \OperatorTok{\&}\NormalTok{a}\OperatorTok{;}
\CommentTok{// or}
\KeywordTok{let}\NormalTok{ p\_a }\OperatorTok{=} \OperatorTok{\&}\NormalTok{a }\KeywordTok{as} \OperatorTok{*}\KeywordTok{const} \DataTypeTok{i32}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You need to be explicit about mutability:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ p\_a}\OperatorTok{:} \OperatorTok{*}\KeywordTok{mut} \DataTypeTok{i32} \OperatorTok{=} \OperatorTok{\&}\KeywordTok{mut}\NormalTok{ a}\OperatorTok{;}
\CommentTok{// or}
\KeywordTok{let}\NormalTok{ p\_a }\OperatorTok{=} \OperatorTok{\&}\KeywordTok{mut}\NormalTok{ a }\KeywordTok{as} \OperatorTok{*}\KeywordTok{mut} \DataTypeTok{i32}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In C++, the difference between a reference and pointer is smaller. Pointers are
compatible with C, and references are a C++-only thing.

In C++ (and C), this is how you make a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{    a =  }\DecValTok{5}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ *p\_a = \&a;}
\CommentTok{// or}
\DataTypeTok{int}\NormalTok{ * p\_a = \&a;}
\CommentTok{// or}
\DataTypeTok{int}\NormalTok{*  p\_a = \&a;}
\end{Highlighting}
\end{Shaded}

You add \texttt{\&} to RHS, but you add \texttt{*} to LHS. Despite the fact that the variable name really is \texttt{p\_a}, not \texttt{*p\_a}, and the type really is \texttt{int*}, many people and formatters prepend the asterisk before the variable name (\texttt{int\ *p\_a\ =\ \&a;}). There are some discussion at \href{https://stackoverflow.com/questions/398395/why-is-the-asterisk-before-the-variable-name-rather-than-after-the-type}{StackOverflow} on why people are preferring this style. I personally prefer using the \texttt{int*\ p\_a\ =\ \&a} style, which is also being used consistently on \href{https://en.cppreference.com/w/cpp/language/pointer}{cppreference}, and in Bjarne Stroustrup's \emph{A Tour of C++}.

Anyway, you can choose whichever form you like when you write your code, but you need to able to read all forms so that you can read others' code.

Note that, unlike in Rust, you cannot create a pointer to a literal in C++:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{* p = \&}\DecValTok{5}\NormalTok{; }\CommentTok{// not allowed!}
\end{Highlighting}
\end{Shaded}

To dereference a pointer, you use the dereference operator, \texttt{*}, which has the same semantics as Rust.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ b = *p\_a;}
\end{Highlighting}
\end{Shaded}

References have similar capabilities as pointers, with the only big difference being their semantics.
This is how you create a reference and read its referent's value:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ l = }\DecValTok{5}\NormalTok{;}
\DataTypeTok{int}\NormalTok{\& m = l;}
\OtherTok{assert}\NormalTok{(m == }\DecValTok{5}\NormalTok{); }\CommentTok{// not \textasciigrave{}*m\textasciigrave{} !}
\end{Highlighting}
\end{Shaded}

You do not need to (and cannot) use the deference operator (\texttt{*}) on a reference to access the value of the referent. In addition, a reference cannot be re-assigned to refer to another value. Apart from these two rules, references are effectively the same as pointers. It can be helpful to see a reference as an \emph{alias} to a \emph{named variable}. Indeed, a reference shares the same memory address as its referent.

Since we are Rustaceans, we are sensitive to mutability. Are there any difference between pointers and references in terms of mutability? The answer is no. Both can be used to mutate the referent.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ a\{}\DecValTok{5}\NormalTok{\};}
    \DataTypeTok{int}\NormalTok{ \&r\_a = a;  }\CommentTok{// create a reference}
    \DataTypeTok{int}\NormalTok{ *p\_a = \&a; }\CommentTok{// create a pointer}
\NormalTok{    printf(}\StringTok{"| a|r\_a|*p\_a|     p\_a      |}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    a = }\DecValTok{10}\NormalTok{; }\CommentTok{// mutate the value}
\NormalTok{    printf(}\StringTok{"|}\SpecialCharTok{\%d}\StringTok{| }\SpecialCharTok{\%d}\StringTok{|  }\SpecialCharTok{\%d}\StringTok{|}\SpecialCharTok{\%p}\StringTok{|}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, r\_a, *p\_a, p\_a);}
\NormalTok{    r\_a = }\DecValTok{15}\NormalTok{; }\CommentTok{// mutate via reference; no asterisk!}
\NormalTok{    printf(}\StringTok{"|}\SpecialCharTok{\%d}\StringTok{| }\SpecialCharTok{\%d}\StringTok{|  }\SpecialCharTok{\%d}\StringTok{|}\SpecialCharTok{\%p}\StringTok{|}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, r\_a, *p\_a, p\_a);}
\NormalTok{    *p\_a = }\DecValTok{20}\NormalTok{; }\CommentTok{// mutate via pointer}
\NormalTok{    printf(}\StringTok{"|}\SpecialCharTok{\%d}\StringTok{| }\SpecialCharTok{\%d}\StringTok{|  }\SpecialCharTok{\%d}\StringTok{|}\SpecialCharTok{\%p}\StringTok{|}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, r\_a, *p\_a, p\_a);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
| a|r_a|*p_a|     p_a      |
|10| 10|  10|0x7ffe09e40404|
|15| 15|  15|0x7ffe09e40404|
|20| 20|  20|0x7ffe09e40404|
\end{verbatim}

I think it would be helpful to make a line-by-line comparison of some common tasks in Rust and in C++:

\hypertarget{reading-the-value-without-mutation-with-a-pointer-or-reference}{%
\subsubsection{Reading The Value Without Mutation with A Pointer or Reference}\label{reading-the-value-without-mutation-with-a-pointer-or-reference}}

\begin{longtable}[]{@{}lllll@{}}
\toprule
\begin{minipage}[b]{0.16\columnwidth}\raggedright
step\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
C++ (pointer)\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
C++ (reference)\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
Rust\strut
\end{minipage} & \begin{minipage}[b]{0.22\columnwidth}\raggedright
Rust (raw pointer)\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.16\columnwidth}\raggedright
init referent\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{const\ int\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{const\ int\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{let\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{let\ \ a\ =\ 5}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.16\columnwidth}\raggedright
make ptr/ref\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{const\ int*\ p\ =\ \&a}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{const\ int\&\ r\ =\ a}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{let\ r:\ \&i32\ =\ \&a}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{let\ p:\ *const\ i32\ =\ \&a;}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.16\columnwidth}\raggedright
read referent value\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{*p}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{r}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
\texttt{*r}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{*p}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{mutating-the-value-of-the-referent-with-a-pointer-or-reference}{%
\subsubsection{Mutating the Value of the Referent with A Pointer or Reference}\label{mutating-the-value-of-the-referent-with-a-pointer-or-reference}}

\begin{longtable}[]{@{}lllll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright
step\strut
\end{minipage} & \begin{minipage}[b]{0.12\columnwidth}\raggedright
C++ (pointer)\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\raggedright
C++ (reference)\strut
\end{minipage} & \begin{minipage}[b]{0.24\columnwidth}\raggedright
Rust\strut
\end{minipage} & \begin{minipage}[b]{0.25\columnwidth}\raggedright
Rust (raw pointer)\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright
init referent\strut
\end{minipage} & \begin{minipage}[t]{0.12\columnwidth}\raggedright
\texttt{int\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\texttt{int\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
\texttt{let\ mut\ a\ =\ 5}\strut
\end{minipage} & \begin{minipage}[t]{0.25\columnwidth}\raggedright
\texttt{let\ mut\ a\ =\ 5}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright
make ptr/ref\strut
\end{minipage} & \begin{minipage}[t]{0.12\columnwidth}\raggedright
\texttt{int*\ p\ =\ \&a}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\texttt{int*\ r\ =\ \&a}\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
\texttt{let\ r:\ \&mut\ i32\ =\ \&mut\ a}\strut
\end{minipage} & \begin{minipage}[t]{0.25\columnwidth}\raggedright
\texttt{let\ p:\ *mut\ i32\ =\ \&mut\ a;}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright
mutate\strut
\end{minipage} & \begin{minipage}[t]{0.12\columnwidth}\raggedright
\texttt{*p\ =\ 10}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\texttt{r\ =\ 10}\strut
\end{minipage} & \begin{minipage}[t]{0.24\columnwidth}\raggedright
\texttt{*r\ =\ 10}\strut
\end{minipage} & \begin{minipage}[t]{0.25\columnwidth}\raggedright
\texttt{*p\ =\ 10}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{control-flow}{%
\section{Control Flow}\label{control-flow}}

C++ offers 5 types of control flow statements. \texttt{if...else}, \texttt{for} loop and \texttt{while} loop are pretty much the same as in Rust, but the \texttt{switch} statement is much less powerful than Rust's \texttt{match}. Additionally there is a \texttt{goto} statement which performs unconditional jump.

If you have experience in Javascript or Java, most of C++'s control flow syntax will be familiar to you. The conditional test associated with \texttt{if}, \texttt{for}, \texttt{while} and \texttt{switch} must be surrounded by parentheses.

\hypertarget{if...else}{%
\subsection{\texorpdfstring{\texttt{if...else}}{if...else}}\label{if...else}}

Like Rust, C++ offers \texttt{if} and \texttt{else} keywords to work with conditionals. Unlike Rust, C++ is not expression-oriented, so you \emph{cannot} write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a = }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{true}\NormalTok{) \{ }\DecValTok{5}\NormalTok{ \} }\ControlFlowTok{else}\NormalTok{ \{ }\DecValTok{10}\NormalTok{ \};}
\end{Highlighting}
\end{Shaded}

But this kind of conditional assignment is a very common pattern, so C++ invented yet another syntax specifically designed for this single task: the ternary operator. So, instead of writing:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a;}
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{true}\NormalTok{) \{ a = }\DecValTok{5}\NormalTok{; \} }\ControlFlowTok{else}\NormalTok{ \{ a = }\DecValTok{10}\NormalTok{; \};}
\end{Highlighting}
\end{Shaded}

you could write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a = }\KeywordTok{true}\NormalTok{ ? }\DecValTok{5}\NormalTok{ : }\DecValTok{10}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

The braces around the statement after the condition of \texttt{if} can be omitted if the statement can be written in a single line.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (i \textgreater{} }\DecValTok{5}\NormalTok{) \{}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} }\StringTok{"i is greater than 5"}\NormalTok{ \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

can be reduced to:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (i \textgreater{} }\DecValTok{5}\NormalTok{)}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} }\StringTok{"i is greater than 5"}\NormalTok{ \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\end{Highlighting}
\end{Shaded}

\hypertarget{while-loop}{%
\subsection{\texorpdfstring{\texttt{while} Loop}{while Loop}}\label{while-loop}}

The \texttt{while} loop in C++ has nothing different from Rust, just remember to wrap the test expression with parentheses.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\DataTypeTok{int}\NormalTok{ i = }\DecValTok{10}\NormalTok{;}
\ControlFlowTok{while}\NormalTok{ (i \textgreater{} }\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
\NormalTok{    i{-}{-};}
    \ControlFlowTok{if}\NormalTok{ (i == }\DecValTok{8}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{continue}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{ (i == }\DecValTok{5}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} i \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{for-loop}{%
\subsection{\texorpdfstring{\texttt{for} Loop}{for Loop}}\label{for-loop}}

A traditional C-style \texttt{for} loop looks like this:

\begin{verbatim}
for (<initializationStatement>; <testExpression>; <updateStatement>)
{
    // do something
}
\end{verbatim}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\NormalTok{printf(}\StringTok{"|i|j|}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} }\DecValTok{2}\NormalTok{; i++)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j \textless{} }\DecValTok{3}\NormalTok{; j++)}
\NormalTok{    \{}
\NormalTok{        printf(}\StringTok{"|}\SpecialCharTok{\%d}\StringTok{|}\SpecialCharTok{\%d}\StringTok{|}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, i, j);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

C++11 introduced the range-based \texttt{for} statement, which is also known as a \texttt{for...in} loop in most other languages (Rust, Swift, Python, Ruby, \ldots). The syntax itself is easy but knowing the relationship between the element and the iterable can be tricky. Fortuantely, we are Rustaceans, so an easy way for me to illustrate and for you to understand is to write a few equivalent examples in Rust and C++.

\hypertarget{scenario-1-copying-cloning}{%
\subsubsection{Scenario 1: Copying (Cloning)}\label{scenario-1-copying-cloning}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{let}\NormalTok{ v }\OperatorTok{=} \PreprocessorTok{vec!}\NormalTok{[}\StringTok{"a"}\OperatorTok{.}\NormalTok{to\_string()}\OperatorTok{,} \StringTok{"b"}\OperatorTok{.}\NormalTok{to\_string()}\OperatorTok{,} \StringTok{"c"}\OperatorTok{.}\NormalTok{to\_string()]}\OperatorTok{;}
\KeywordTok{for}\NormalTok{ e}\OperatorTok{.}\NormalTok{clone() }\KeywordTok{in} \OperatorTok{\&}\NormalTok{v }\OperatorTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\OperatorTok{,}\NormalTok{ e)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// C++}
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}vector\textgreater{}}
\BuiltInTok{std::}\NormalTok{vector\textless{}}\BuiltInTok{std::}\NormalTok{string\textgreater{} a\{}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{\};}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{auto}\NormalTok{ s : a) }\CommentTok{// s has type \textasciigrave{}std::string\textasciigrave{}}
\NormalTok{\{}
    \BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} s \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note how Rust makes it crystal clear that copying during iteration and using \texttt{String} for instead of \texttt{\&str} for static strings are anti-patterns and how C++ makes it easy to write such inefficient code.

\hypertarget{scenario-2-as-reference-borrowing}{%
\subsubsection{Scenario 2: As Reference (Borrowing)}\label{scenario-2-as-reference-borrowing}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{let}\NormalTok{ v }\OperatorTok{=} \PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\NormalTok{]}\OperatorTok{;}
\KeywordTok{for}\NormalTok{ e }\KeywordTok{in} \OperatorTok{\&}\NormalTok{v }\OperatorTok{\{}
    \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\OperatorTok{,} \OperatorTok{*}\NormalTok{e)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// C++}
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}vector\textgreater{}}
\BuiltInTok{std::}\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} a\{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{\};}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{auto}\NormalTok{\& num : a)}
\NormalTok{\{}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{, num); }\CommentTok{// no asterisk!}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{scenario-3-mutation}{%
\subsubsection{Scenario 3: Mutation}\label{scenario-3-mutation}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Rust}
\KeywordTok{let} \KeywordTok{mut}\NormalTok{ v }\OperatorTok{=} \PreprocessorTok{vec!}\NormalTok{[}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\NormalTok{]}\OperatorTok{;}
\KeywordTok{for}\NormalTok{ e }\KeywordTok{in} \OperatorTok{\&}\KeywordTok{mut}\NormalTok{ v }\OperatorTok{\{}
    \OperatorTok{*}\NormalTok{e }\OperatorTok{=} \OperatorTok{*}\NormalTok{e }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\PreprocessorTok{assert\_eq!}\NormalTok{(v}\OperatorTok{,} \PreprocessorTok{vec!}\NormalTok{[}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// C++}
\PreprocessorTok{\#include }\ImportTok{\textless{}vector\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}cassert\textgreater{}}
\BuiltInTok{std::}\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} a\{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{\};}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{auto}\NormalTok{ \&num : a)}
\NormalTok{\{}
\NormalTok{    num++;}
\NormalTok{\}}
\OtherTok{assert}\NormalTok{(a == (}\BuiltInTok{std::}\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{}\{}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{\}));}
\end{Highlighting}
\end{Shaded}

Note the parentheses surrounding the second argument of \texttt{assert}, without which we would get an error. This is because \texttt{assert} is a so called \texttt{\#define} macro, which simply parses its arguments as comma-separated identifiers and does text replacement. Since \texttt{std::vector\textless{}int\textgreater{}\{2,\ 3,\ 4,\ 5,\ 6\}} contains commas, it has to be escaped with parentheses.\footnote{Related to this stackoverflow question: \url{https://stackoverflow.com/questions/38030048}} This macro is actually defined in \texttt{assert.h} which is part of C's std, and its more or less copied verbatim into C++'s \texttt{cassert}.

\hypertarget{goto-statement-and-breaking-outer-loops}{%
\subsection{\texorpdfstring{\texttt{goto} Statement and Breaking outer Loops}{goto Statement and Breaking outer Loops}}\label{goto-statement-and-breaking-outer-loops}}

Rust, like Java and Python, allows you to break an outer loop from an inner loop:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for}\NormalTok{ i }\KeywordTok{in} \DecValTok{0}\OperatorTok{..}\DecValTok{3} \OperatorTok{\{}
    \OtherTok{\textquotesingle{}for\_j}\OperatorTok{:} \KeywordTok{for}\NormalTok{ j }\KeywordTok{in} \DecValTok{0}\OperatorTok{..}\DecValTok{3} \OperatorTok{\{}
        \KeywordTok{for}\NormalTok{ k }\KeywordTok{in} \DecValTok{0}\OperatorTok{..}\DecValTok{3} \OperatorTok{\{}
            \KeywordTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{1} \OperatorTok{\{}
                \KeywordTok{break} \OtherTok{\textquotesingle{}for\_j}\OperatorTok{;}
            \OperatorTok{\}}
            \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\} \{\} \{\}"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{,}\NormalTok{ k)}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C++ doesn't support this natively, so it's common to use the \texttt{goto} trick to achive this\footnote{\url{https://stackoverflow.com/questions/1257744/can-i-use-break-to-exit-multiple-nested-for-loops}}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}
\DataTypeTok{void}\NormalTok{ break\_outer()}
\NormalTok{\{}
\NormalTok{    printf(}\StringTok{"Break outer loop using goto:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"i j k}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} }\DecValTok{3}\NormalTok{; ++i)}
\NormalTok{    \{}

        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j \textless{} }\DecValTok{3}\NormalTok{; ++j)}
\NormalTok{        \{}
            \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ k = }\DecValTok{0}\NormalTok{; k \textless{} }\DecValTok{3}\NormalTok{; ++k)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{ (i == }\DecValTok{1}\NormalTok{)}
\NormalTok{                \{}
                    \ControlFlowTok{goto}\NormalTok{ for\_j\_end;}
\NormalTok{                \}}
\NormalTok{                printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, i, j, k);}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    for\_j\_end:}
\NormalTok{    \{}
        \CommentTok{// cannot be left blank. Needs a placeholder}
\NormalTok{    \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{goto} statement must be in the same function as the label it is referring,
so duplicated labels across different functions won't cause conflicts.

Alternatively you can use a flag, which is more verbose, and I think this is even less readable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf(}\StringTok{"Break outer loop using flag:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{printf(}\StringTok{"i j k}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\DataTypeTok{bool}\NormalTok{ i\_is\_1\{}\KeywordTok{false}\NormalTok{\};}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} }\DecValTok{3}\NormalTok{; ++i)}
\NormalTok{\{}

    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j \textless{} }\DecValTok{3}\NormalTok{; ++j)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ k = }\DecValTok{0}\NormalTok{; k \textless{} }\DecValTok{3}\NormalTok{; ++k)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (i == }\DecValTok{1}\NormalTok{)}
\NormalTok{            \{}
\NormalTok{                i\_is\_1 = }\KeywordTok{true}\NormalTok{;}
                \ControlFlowTok{break}\NormalTok{;}
\NormalTok{            \}}
            \ControlFlowTok{else}
\NormalTok{            \{}
\NormalTok{                i\_is\_1 = }\KeywordTok{false}\NormalTok{;}
\NormalTok{            \}}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, i, j, k);}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{ (i\_is\_1)}
\NormalTok{        \{}
            \ControlFlowTok{break}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There is another cleaner way, using the lambda trick (less common than the \texttt{goto} approach):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf(}\StringTok{"Break outer loop using lambda:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{printf(}\StringTok{"i j k}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} }\DecValTok{3}\NormalTok{; ++i)}
\NormalTok{\{}
\NormalTok{    [\&] \{}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j \textless{} }\DecValTok{3}\NormalTok{; ++j)}
\NormalTok{        \{}
            \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ k = }\DecValTok{0}\NormalTok{; k \textless{} }\DecValTok{3}\NormalTok{; ++k)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{ (i == }\DecValTok{1}\NormalTok{)}
\NormalTok{                \{}
                    \ControlFlowTok{return}\NormalTok{;}
\NormalTok{                \}}
\NormalTok{                printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, i, j, k);}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

I'll get back to lamdas later. For now just accept that they are roughly equivalent to Rust's closures.

\hypertarget{switch}{%
\subsection{\texorpdfstring{\texttt{switch}}{switch}}\label{switch}}

C++'s \texttt{switch} is essentially a shortcut for a series of \texttt{if...else\ if...else\ if...else} statements when you want to match the value a single expression to a range of constant values. For example:

The following C++ code

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ d = }\DecValTok{5}\NormalTok{;}
\ControlFlowTok{if}\NormalTok{ (d == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Sunday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (d == }\DecValTok{6}\NormalTok{) \{}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Saturday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s weekday.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

is equivalent to:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch}\NormalTok{ (d)}
\NormalTok{\{}
\ControlFlowTok{case} \DecValTok{0}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Sunday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\ControlFlowTok{case} \DecValTok{6}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Saturday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\ControlFlowTok{default}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s weekday.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(I'll start to omit headers from now on.)

Note the \texttt{break} statement at the end of each \texttt{case}, without which the \texttt{default} branch will always be triggered, which is clearly not we mean to do\footnote{This \href{https://stackoverflow.com/questions/252489/why-was-the-switch-statement-designed-to-need-a-break}{StackOverflow question} might be interesting.}.

You can group several values into a single branch:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ d = }\DecValTok{5}\NormalTok{;}
\ControlFlowTok{switch}\NormalTok{ (d)}
\NormalTok{\{}
\ControlFlowTok{case} \DecValTok{0}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Sunday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\ControlFlowTok{case} \DecValTok{6}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s Saturday!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\ControlFlowTok{case} \DecValTok{1}\NormalTok{:}
\ControlFlowTok{case} \DecValTok{2}\NormalTok{:}
\ControlFlowTok{case} \DecValTok{3}\NormalTok{:}
\ControlFlowTok{case} \DecValTok{4}\NormalTok{:}
\ControlFlowTok{case} \DecValTok{5}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"It\textquotesingle{}s weekday.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\ControlFlowTok{default}\NormalTok{:}
\NormalTok{    printf(}\StringTok{"Not a valid day of week!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{break}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is all about \texttt{switch} in C++. (You need to unlearn the pattern matching in Rust)

\hypertarget{exercise}{%
\section*{Exercise}\label{exercise}}
\addcontentsline{toc}{section}{Exercise}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Pointers and references.}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x = }\DecValTok{5}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ y = }\DecValTok{10}\NormalTok{;}
\DataTypeTok{int}\NormalTok{* px = \&x;}
\DataTypeTok{int}\NormalTok{* py = \&y;}
\NormalTok{px = py;}
\CommentTok{// What are the values of x, y, *px and *py now?}

\DataTypeTok{int}\NormalTok{ i = }\DecValTok{5}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ j = }\DecValTok{10}\NormalTok{;}
\DataTypeTok{int}\NormalTok{\& ri = i;}
\DataTypeTok{int}\NormalTok{\& rj = j;}
\NormalTok{ri = rj;}
\CommentTok{// What are the values of i, j, ri and rj now?}
\CommentTok{// Hint: a reference cannot be re{-}assigned. What\textquotesingle{}s the last line doing?}
\end{Highlighting}
\end{Shaded}

\hypertarget{enumerations}{%
\chapter{Enumerations}\label{enumerations}}

Like Rust, C++ has \texttt{enum}s. Unlike Rust, their \texttt{enum}s are much less powerful. C++`s enumeration
comes in two flavors: the plain, C-compatible \texttt{enum}, and the \texttt{enum\ class}. Generally, you should
always use an \texttt{enum\ class}, but you should also learn about the plain \texttt{enum} in order to read
others' code.

\hypertarget{the-plain-enum}{%
\section{\texorpdfstring{The Plain \texttt{enum}}{The Plain enum}}\label{the-plain-enum}}

\hypertarget{defining-an-enum}{%
\subsection{Defining an Enum}\label{defining-an-enum}}

The syntax for defining an \texttt{enum} in C++ is similar to Rust. In addition, like in Rust, enum
variants are represented as integers at the low level, and by default the value starts from 0.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ LogLevel}
\NormalTok{\{}
\NormalTok{    Debug,   }\CommentTok{// 0}
\NormalTok{    Info,    }\CommentTok{// 1}
\NormalTok{    Warning, }\CommentTok{// 2}
\NormalTok{    Error    }\CommentTok{// 3}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

You can also manually assign values to the variants (also valid in Rust):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ LogLevel}
\NormalTok{\{}
\NormalTok{    Debug   = }\BaseNTok{0x12}\NormalTok{,}
\NormalTok{    Info    = }\BaseNTok{0xd1}\NormalTok{,}
\NormalTok{    Warning = }\BaseNTok{0x7c}\NormalTok{,}
\NormalTok{    Error   = }\BaseNTok{0x0a}\NormalTok{,}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Unlike Rust, C++ by default uses the \texttt{int} type to represent the variants, even though most of the
time the number of variants won't exceed 256. To use a more compact representation, you can do:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ MyEnum : }\DataTypeTok{uint8\_t}
\CommentTok{// or \textasciigrave{}enum Foo : char\textasciigrave{} (remember that \textasciigrave{}char\textasciigrave{} is an integer type)}
\NormalTok{\{}
\NormalTok{    Foo,}
\NormalTok{    Bar,}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-an-enum}{%
\subsection{Using an Enum}\label{using-an-enum}}

Unlike Rust, a C++ \texttt{enum} does not create a namespace, which means you cannot write \texttt{LogLevel::Info}
to refer to the \texttt{Info} variant of the \texttt{LogLevel} enum defined in the prevous subsection. You should
write \texttt{Info} directly.

A enum is implicitly converted to an integer. Which means it can be directly compared to an integer
(but dont't actually do this) and can be pushed to \texttt{std::cout} directly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LogLevel lvl = Info;}
\OtherTok{assert}\NormalTok{(Info == }\DecValTok{1}\NormalTok{);}
\OtherTok{assert}\NormalTok{(Warning \textgreater{} }\DecValTok{1}\NormalTok{);}
\OtherTok{assert}\NormalTok{(Error \textgreater{} Debug);}
\BuiltInTok{std::}\NormalTok{cout \textless{}\textless{} lvl \textless{}\textless{} }\BuiltInTok{std::}\NormalTok{endl;}
\end{Highlighting}
\end{Shaded}

However, an integer cannot be converted implicitly into an enum, but can be done so explicitly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LogLevel lvl = }\DecValTok{2}\NormalTok{;           }\CommentTok{// won\textquotesingle{}t work}
\NormalTok{LogLevel lvl = (LogLevel)}\DecValTok{2}\NormalTok{; }\CommentTok{// OK, but don\textquotesingle{}t actually do this}
\end{Highlighting}
\end{Shaded}

You can reassign the identifier \texttt{Info} to another value

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ Info = }\DecValTok{999}\NormalTok{;}
\end{Highlighting}
\end{Shaded}

\ldots but can you set another \texttt{LogLevel} to \texttt{Info}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LogLevel m = Info; }\CommentTok{// Error!}
\end{Highlighting}
\end{Shaded}

No you can't. C++ generally forbids re-defining variables, but in the case of
enums you are allowed to re-bind a enum variant identifier (\texttt{Info}) to another
value (\texttt{999}), then you just can't use that enum variant.

To avoid this and other kinds of conflicts, it had been a common practice to
enum variants with part of the enum name. For example, the \texttt{LogLevel} enum
may be rewritten as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ LogLevel}
\NormalTok{\{}
\NormalTok{    LevelDebug,}
\NormalTok{    LevelInfo,}
\NormalTok{    LevelWarning,}
\NormalTok{    LevelError}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\ldots which violates the DRY rule in a bad way. To solve this problem, \texttt{enum\ class} was introduced
in C++11, and we'll learn about it in the next section.

  \bibliography{book.bib}

\end{document}
